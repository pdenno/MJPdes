

;;;===== 2016-11-01 =====================================

These values are for execution without logging

Stop at time= 20,000
(time (main-loop f1))
"Elapsed time: 27157.07128 msecs"

Stop at time= 200,000
"Elapsed time: 190078.142779 msecs"  About 3:10. Acceptable!


;;;=========== 2016-11-03 =================================

Nope, this is OK. Job 3 is added (to :m1) just when Job 2 ends. Thus they have similar times. 

{:action :+Job, :jobId 2, :jobType :jobType1, :clock 1.0, :ends 2.809690864595441}
{:action :onMach, :clock 1.0, :machine :m2, :jobId 1, :ends 2.0}
{:action :unstarved, :clock 1.0, :machine :m2}
{:action :bufJob, :machine :m2, :jobId 1, :clock 2.0}
{:action :onMach, :clock 2.0, :machine :m3, :jobId 1, :ends 3.0}
{:action :starved, :clock 2.0, :machine :m2}
{:action :unstarved, :clock 2.0, :machine :m3}
{:action :bufJob, :machine :m1, :jobId 2, :clock 2.809690864595441}
{:action :+Job, :jobId 3, :jobType :jobType1, :clock 2.809690864595441, :ends 3.809690864595441}
{:action :onMach, :clock 2.809690864595441, :machine :m2, :jobId 2, :ends 3.809690864595441}


;;;==================== "2016-11-06:11-12-47" ==============

{:avg-job-cycle 7.094009477743227,
 :number-of-jobs 605946,
 :blocked
 {:m1 0.10442671666663554,   ; Pooya 0.1860
  :m2 0.021265105555553943,  ; Pooya 0.0346
  :m3 0.05552185555555572,   ; Pooya 0.1046
  :m4 0.020180305555556718,  ; Pooya 0.0398
  :m5 0.0},                  
 :starved
 {:m1 0.0,
  :m2 4.7977777777689176E-5,
  :m3 1.3022777777819605E-4,
  :m4 4.314111111119726E-4,
  :m5 0.0}}

{:avg-job-cycle 7.075193653623746,
 :number-of-jobs 604786,
 :blocked
 {:m1 0.10625019444444081,
  :m2 0.022049316666668286,
  :m3 0.0565281166666691,
  :m4 0.021402255555556398,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 3.3527777777756757E-5,
  :m3 2.0994444444378234E-4,
  :m4 3.8156666666687265E-4,
  :m5 0.0}}

{:avg-job-cycle 7.04650339397464,
 :number-of-jobs 605043,
 :blocked
 {:m1 0.10517359444445838,
  :m2 0.02111279444444234,
  :m3 0.05539747222221587,
  :m4 0.020953722222222394,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 7.082222222250291E-5,
  :m3 1.9387777777746024E-4,
  :m4 4.446555555560634E-4,
  :m5 0.0}}

;;; This one with +jobs-move-to-down-machines+ = true (dosn't matter).
;;; (Might matter if down time is more significant.)

{:avg-job-cycle 7.094810987109734,
 :number-of-jobs 605546,
 :blocked
 {:m1 0.10516593888885942,
  :m2 0.02203047777777384,
  :m3 0.05523561111111806,
  :m4 0.020702750000002764,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 3.371666666676497E-5,
  :m3 2.0220555555574215E-4,
  :m4 4.459333333333941E-4,
  :m5 0.0}}


;;; It could be that Pooya isn't considering whether or not the work is finished
;;; (for both blocking and starved). 

(defn new-starved?
  "Return record-actions to list certain machines as starved."
  [model]
  (let [clock (:clock model)
        old-starved (:starved model)
        new-starved (as-> (:line model) ?m
                        (vals ?m)
                        (filter machine? ?m)
                        (filter #(finished? model %) ?m) ; <=====================
                        (filter #(not (contains? old-starved (:name %))) ?m)
                        (filter #(feed-buffer-empty? model %) ?m))]
    (when (not-empty new-starved)
      (map (fn [mn] `(~clock (new-starved ~(:name mn)))) new-starved))))


;;; Let's try without regard to whether a job is on the machine.

{:avg-job-cycle 7.0452649511398215,
 :number-of-jobs 606927,
 :blocked
 {:m1 0.7629009055555672,  ; Now they are way too high. Shooting for 0.186
  :m2 0.24493372777778713,
  :m3 0.6272473555555458,
  :m4 0.17197511111109806,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 3.320555555546889E-5,
  :m3 2.2427222222225587E-4,
  :m4 4.450499999997596E-4,
  :m5 0.0}}

;;; I can run 2000/20000 without too much difference. Good!

{:avg-job-cycle 7.04650339397464, ; (200,000)
 :number-of-jobs 605043,
 :blocked
 {:m1 0.10517359444445838,
  :m2 0.02111279444444234,
  :m3 0.05539747222221587,
  :m4 0.020953722222222394,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 7.082222222250291E-5,
  :m3 1.9387777777746024E-4,
  :m4 4.446555555560634E-4,
  :m5 0.0}}

{:avg-job-cycle 7.204792225355413, ; (20,000)
 :number-of-jobs 60633,
 :blocked
 {:m1 0.10278211111110526,
  :m2 0.023915944444444222,
  :m3 0.05800272222222217,
  :m4 0.021745111111111617,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.0,
  :m3 1.1261111111101248E-4,
  :m4 4.1566666666670294E-4,
  :m5 0.0},
 :status :normal-end}

;;; The above should have reflected a bug fix in 

;;; PSE Toolbox fig 3.1(a)
{:blocked
 {:m1 0.1860
  :m2 0.0346
  :m3 0.1046
  :m4 0.0398
  :m5 0.0},
 :starved
 {:m1 0.0
  :m2 0.0089
  :m3 0.0186
  :m4 0.0462
  :m5 0.1860},
 :status :normal-end}

;;; PSE Toolbox fig 3.1(b)
{:blocked
 {:m1 0.1501
  :m2 0.0001
  :m3 0.0258
  :m4 0.0061
  :m5 0.0},
 :starved
 {:m1 0.0
  :m2 0.0001
  :m3 0.0578
  :m4 0.0371
  :m5 0.1501},
 :status :normal-end}


;;;; Back to debugging:

{:avg-job-cycle 7.094009477743227,
 :number-of-jobs 605946,
 :blocked
 {:m1 0.10442671666663554,   ; Pooya 0.1860
  :m2 0.021265105555553943,  ; Pooya 0.0346
  :m3 0.05552185555555572,   ; Pooya 0.1046
  :m4 0.020180305555556718,  ; Pooya 0.0398
  :m5 0.0},                  
 :starved
 {:m1 0.0,
  :m2 4.7977777777689176E-5, ; Pooya 0.0089
  :m3 1.3022777777819605E-4, ; Pooya 0.0186
  :m4 4.314111111119726E-4,  ; Pooya 0.0462
  :m5 0.0}}                  ; Pooya 0.1860


{:avg-job-cycle 7.103788367674157,
 :number-of-jobs 61054,
 :blocked
 {:m1 0.0964086111111159,
  :m2 0.0209067777777772,
  :m3 0.06078016666666583,
  :m4 0.01850972222222232,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 1.0466666666656642E-4,
  :m3 9.783333333325573E-5,
  :m4 2.3911111111134335E-4,
  :m5 0.0},
 :bneck :m2,
 :status :normal-end}

--> I see that the log does not start with starvations. (fixed, matters)
--> Also, there was an error with an 'if' in logging.   (fixed, doesn matter)

{:avg-job-cycle 12.70638891096972, <--- hmmm
 :number-of-jobs 15096,
 :blocked
 {:m1 0.10468494444444416,
  :m2 0.02147822222222207,
  :m3 0.05829505555555312, ; not changed. 
  :m4 0.018650499999999095,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.009031388888888424, ; pooya 0.0089 good
  :m3 0.03873405555556193,  ; pooya 0.0186 
  :m4 0.06809227777777878,  ; pooya 0.0462 
  :m5 0.2125962222222221},  ; pooya 0.186
 :bneck :m2,
 :status :normal-end}


{:avg-job-cycle 12.652848096218975,
 :number-of-jobs 15049,
 :blocked
 {:m1 0.10544000000000346,
  :m2 0.02234349999999972,
  :m3 0.055649166666664945,
  :m4 0.02084749999999912,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.009663888888889435,
  :m3 0.038886833333330366,
  :m4 0.07603705555555364,
  :m5 0.21601377777778444},
 :bneck :m2,
 :status :normal-end}

{:avg-job-cycle 12.983051319550595,
 :number-of-jobs 15043,
 :blocked
 {:m1 0.11024705555555205,
  :m2 0.023838722222223094,
  :m3 0.054339722222225315,
  :m4 0.021980611111111607,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.007074722222222337,
  :m3 0.03467311111110814,
  :m4 0.07394127777778291,
  :m5 0.2096478333333297},
 :bneck :m2,
 :status :normal-end}

;;; Removed (finished? m) in feed-buffer-empty? Ugh!
;;; No difference.

{:avg-job-cycle 12.958822618022952,
 :number-of-jobs 15103,
 :blocked
 {:m1 0.10693588888889231,
  :m2 0.02188455555555528,
  :m3 0.05516477777777754,
  :m4 0.02267111111111189,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.008165833333332886,
  :m3 0.034972222222226595,
  :m4 0.07216599999999815,
  :m5 0.20757866666666697},
 :bneck :m2,
 :status :normal-end}

;;; w = 4.0
{:avg-job-cycle 41.77436979385765,
 :number-of-jobs 40409,     <======================= was 20,000/200,000
 :blocked
 {:m1 0.0723067555555584,
  :m2 4.1954444444468716E-4,
  :m3 0.01766993888889075,
  :m4 0.0016857722222217086,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 5.83166666667239E-5,
  :m3 0.04710497222222366,
  :m4 0.04183628333333078,
  :m5 0.15862715555554663},
 :bneck :m2,
 :status :normal-end}

;;; ============= "2016-11-07:10-18-43" ========================

I cleaned up :ss / :bs, setting to nil after unstarve/unblock. No change.

{:avg-job-cycle-time 12.814980064477925,
 :number-of-jobs 15199,
 :blocked
 {:m1 0.10270138888887491,
  :m2 0.0206412222222229,
  :m3 0.05702477777777717,
  :m4 0.02141505555555467,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.0075000555555563625,
  :m3 0.032662555555553835,
  :m4 0.06629377777777715,
  :m5 0.2026343888888896},
 :bneck :m2,
 :status :normal-end}


{:avg-job-cycle-time 12.691509087330264,
 :number-of-jobs 15241,
 :blocked
 {:m1 0.0995516111110958,
  :m2 0.020982388888887916,
  :m3 0.054894388888887154,
  :m4 0.019941111111111607,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.01033383333333351,
  :m3 0.032513611111104054,
  :m4 0.06575649999999224,
  :m5 0.20893094444444515},
 :bneck :m2,
 :status :normal-end}

The numbers from PSE Toolbox match Pooya's exactly. Additionally
TP = 0.8569 Parts/min       My TP (below is 0.83975)
WIP = [2.6 2.88 0.72 0.16]

{:avg-job-cycle-time 12.910839727432258,
 :number-of-jobs 151155,
 :blocked
 {:m1 0.1057470388888749,
  :m2 0.02206308888888713,
  :m3 0.05623731111110723,
  :m4 0.020236544444443016,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.008588155555552618,
  :m3 0.032930816666662394,
  :m4 0.06936350000001724,
  :m5 0.20913961666666842},
 :bneck :m2,
 :status :normal-end}
"Elapsed time: 389703.791302 msecs"


---> The troubling thing is that my throughput is within 2 percent of theirs;
     everything else is different (though behavior looks good).

This suggests that the way I'm calculating blockage and starvation might be different.

---> Should also calculate WIP to see how that differs. In fact, WIP values of 0 and N
     should be telling about ST and BL.

{:runtime 180000,
 :TP 0.8422722
 :avg-job-cycle-time 12.833051263447542,
 :number-of-jobs 151609,
 :blocked
 {:m1 0.10438964999999435,  56%
  :m2 0.02149936666666662,  62%
  :m3 0.05510053333333427,  52%
  :m4 0.020698694444444665, 52%
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.00823358888888779,   92%
  :m3 0.03407648888890605,  182%
  :m4 0.06830172222221233,  148%
  :m5 0.20548936111114038}, 110%
 :bneck :m2,
 :status :normal-end}
"Elapsed time: 309819.416973 msecs"


; Here is one with finer-grained machine up&down. (0.01/0.09) 
; Blocked is very similar to Pooya at 0.1/0.9. Starved is much different.
; "In particular, shorter Tup and Tdown lead to larger throughput than longer ones, even it
;  T_up/T_down = e is fixed. Yeah, but I have lambda, mu (RATEs): lower rate means longer Tup,
; Tup and Tf are defined by = lamba e^(-lambda t)


{:runtime 180000, 
 :TP 0.66536665,
 :avg-job-cycle-time 14.707579204454134,
 :number-of-jobs 119766,
 :blocked
 {:m1 0.15418268333326676,
  :m2 0.04936911666666583,
  :m3 0.10811461111110954,
  :m4 0.05516892777777735,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.06466941666667109,
  :m3 0.14457773333333257,
  :m4 0.2057352999999686,
  :m5 0.36226028888890716},
 :bneck :m2,
 :status :normal-end}
"Elapsed time: 279955.676118 msecs"


{:runtime 180000,
 :TP 0.84085554,
 :avg-job-cycle-time 12.891974939546083,
 :number-of-jobs 151354,
 :blocked
 {:m1 0.1056912888888628,
  :m2 0.022476799999999922,
  :m3 0.055434061111111196,
  :m4 0.021397261111113484,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.00775101111111253,
  :m3 0.033362261111088386,
  :m4 0.06919611111111931,
  :m5 0.20715742222225106},
 :bneck :m2,
 :status :normal-end}
"Elapsed time: 311754.345537 msecs"

---> TWO THINGS here:
1) First the current problem: Why is :n 0 still 0.0 everywhere
2) Why are :bs and :ss nil everywhere? A: I think I set it that way.


{:m5 {:blocked 0.0, :starved 3711.751000000042, :bs nil, :ss nil},
 :b2
 {0 0.0,
  1 1077.0250000000017,
  2 1081.208999999987,
  3 1264.9170000000406,
  4 1316.2240000000493,
  5 4113.395999999994,
  :lastclk 19999.956},
 :m3
 {:blocked 933.9829999999595,
  :starved 678.6560000000798,
  :bs nil,
  :ss nil},
 :b1
 {0 0.0,
  1 609.6640000000268,
  2 954.818000000023,
  3 13491.083999999977,
  :lastclk 19999.956},
 :m4
 {:blocked 396.6939999999677,
  :starved 1281.822999999892,
  :bs nil,
  :ss nil},
 :b4 {0 0.0, 1 3269.3819999999737, :lastclk 19999.909},
 :m2
 {:blocked 365.5819999999792,
  :starved 192.78299999999263,
  :bs nil,
  :ss nil},
 :b3 {0 0.0, 1 10933.72599999995, :lastclk 19999.909},
 :m1 {:blocked 1901.6200000000115, :starved 0.0, :bs nil, :ss nil}}

--> Problem: Never see :n=0 because that doesn't happen in a :sm message. Need work on :bj
    and use the n-values on the decremented buffer size. 

--> Sum the buffer times to get run-time.


gov.nist.desim> (apply + (vals (dissoc (:b1 (dissoc @+diag+ :jcycles)) :lastclk)))
16025.451000000232
gov.nist.desim> (apply + (vals (dissoc (:b2 (dissoc @+diag+ :jcycles)) :lastclk)))
12596.35999999983
gov.nist.desim> (apply + (vals (dissoc (:b3 (dissoc @+diag+ :jcycles)) :lastclk)))
17999.146
gov.nist.desim> (apply + (vals (dissoc (:b4 (dissoc @+diag+ :jcycles)) :lastclk)))
17999.525

So the ones with just two states (n={0, 1} for :b3 and :b4) look okay. The others are goofed up.

gov.nist.desim> (dissoc (:b4 (dissoc @+diag+ :jcycles)) :lastclk)
{0 14885.878000000006, 1 3113.6469999999963}

:b1 {0 579.1309999999539, 1 459.1370000000252, 2 881.6710000000671, 3 14105.512000000186}
:b2 {0 3493.410000000117, 1 1118.4169999998985, 2 1202.032999999814, 3 1132.9599999999955, 4 1242.2180000000644, 5 4407.32199999994}

=====> Maybe the mistake I am making here is repeated in accounting for ST and BL

ONE MORE THING: Make sure analyze-results isn't using the model for anything but topology.
                Maybe even send it a model with :dissoc :line. 

;;;============== "2016-11-09:17-18-07" =======================

Hurray! Progress!

gov.nist.desim> (apply + (vals (dissoc (:b1 (dissoc @+diag+ :jcycles)) :lastclk)))
17999.405
gov.nist.desim> (apply + (vals (dissoc (:b2 (dissoc @+diag+ :jcycles)) :lastclk)))
17999.624
gov.nist.desim> (apply + (vals (dissoc (:b3 (dissoc @+diag+ :jcycles)) :lastclk)))
17999.624
gov.nist.desim> (apply + (vals (dissoc (:b4 (dissoc @+diag+ :jcycles)) :lastclk)))
17999.624

This was fixed by recognizing the symmetry between :bj and :sm. Now, should I expect
similar symmetry among ST and BL calculations?

These have, for example, :bl and :ub which are just two states. I want only to
record the time from  :bl and :ub, and NEVER from :ub to :bl. ... It looks like
the (simple) code is okay in this respect. 

--> The problem might be that I need to think about the order in which actions
occurring at the same time are serialized ???

BTW, my blocked numbers are too low and by starved numbers are too high. 

So if these WIP numbers are correct, it should be possible to calculate the
average cycle time very accurately. (But do it for 180,000) Use the blockage
and starvation values (percentages) as percentage reduction of machine efficiency 
(W values). Is that correct?
Multiply the queue length times adjusted service times. This is
why blocked-requires-not-starved should matter -- don't get charged twice for
down time.

--> I don't think what I did makes sense. The blockage and starved should be delays on
movement, not part of machine efficency.

MUST CHECK MATH (conceptualization) USING PSE Toolkit

Step 1: Job requires : (0.8333333333333334 1.0 0.9090909090909091 0.9523809523809523 0.8333333333333334)

Call these :job-cycle-time-observed and :job-cycle-time-computed

{:runtime 180000,
 :TP 0.84205,
 :avg-job-cycle-time 12.870383930751125,
 :number-of-jobs 151569,
 :blocked
 {:m1 0.10431987222224323,
  :m2 0.021629288888884084,
  :m3 0.055769538888887936,
  :m4 0.02075238333333002,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.008285311111111636,
  :m3 0.03238297222223151,
  :m4 0.06827487777777878,
  :m5 0.20686249999997902},
 :wip
 {:b1 2.6262400555555296,
  :b2 2.7682855277778193,
  :b3 0.6247810888888722,
  :b4 0.1778069388888893},
 :bneck :m2,
 :status :normal-end}

;;; Very little point in running 180,000

{:runtime 18000,
 :TP 0.83805555,
 :avg-job-cycle-time 12.973119390122697,
 :number-of-jobs 15085,
 :blocked
 {:m1 0.10504055555555745,
  :m2 0.02222549999999991,
  :m3 0.05859350000000393,
  :m4 0.02027416666666756,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.008699000000000902,
  :m3 0.03497899999999906,
  :m4 0.069696999999999,
  :m5 0.20737349999999516},
 :wip
 {:b1 2.620139722222238,
  :b2 2.807872222222217,
  :b3 0.6275918333333322,
  :b4 0.18037438888888876},
 :bneck :m2,
 :status :normal-end}


{:runtime 18000,
 :TP 0.8408333,
 :avg-job-cycle-time 12.618829071688083,
 :number-of-jobs 15135,
 :blocked
 {:m1 0.10583166666666888,
  :m2 0.02081700000000036,
  :m3 0.05729172222222343,
  :m4 0.020110833333333127,
  :m5 0.0},
 :starved
 {:m1 0.0,
  :m2 0.009631944444445026,
  :m3 0.03914016666666614,
  :m4 0.07063649999999713,
  :m5 0.21237483333333346},
 :wip
 {:b1 2.6048146111111095,
  :b2 2.5791191111111007,
  :b3 0.6193226666666594,
  :b4 0.1668682777777777},
 :bneck :m2,
 :status :normal-end}

;;;====================== "2016-11-10:10-22-06" ==============

Here is a results map for fig 3.2a problem, analytical (input, hand-written):

(def in32
     {:TP 0.8569
      :observed-cycle-time 12.853847952828948,
       :computed-job-cycle-time 11.22625294521394,
        :wip
	 {:b1 2.6
	   :b2 2.88
	     :b3 0.72
	       :b4 0.16},
	        :number-of-jobs 15094,
		 :status :normal-end,
		  :runtime 18000,
		   :bneck :m2,
		    :starved
		     {:m1 0.0,
		       :m2 0.0089,
		         :m3 0.0186,
			   :m4 0.0462, 
			     :m5 0.1860},
			      :blocked
			       {:m1 0.1860,
			         :m2 0.0346,
				   :m3 0.1046,
				     :m4 0.0398,
				       :m5 0.0}})


;;; The exponential checks out. exponential up&down seems to be correct.

;;; Let's focus on blocking on :m1 remove everything else from the log....

{:TP 0.83772224,
 :observed-cycle-time 13.121410438357925,
 :wip
 {:b1 2.6343181666666675,
  :b2 2.8708756666666755,
  :b3 0.6419434444444451,
  :b4 0.18117255555555356},
 :number-of-jobs 15079,
 :computed-cycle-time 11.38829120243176,
 :status :normal-end,
 :runtime 18000,
 :bneck :m2,
 :starved
 {:m1 0.0,
  :m2 0.006904055555555235,
  :m3 0.02882466666667291,
  :m4 0.0626477222222239,
  :m5 0.20536477777778012},
 :blocked
 {:m1 0.10565194444444811,
  :m2 0.023152722222221606,
  :m3 0.062168555555557496,
  :m4 0.02302466666666689,
  :m5 0.0}}


This kind of thing:

{:act :ub, :m :m1, :clk 19994.501}

{:act :bl, :m :m1, :clk 19995.501}
{:act :ub, :m :m1, :clk 19995.501}

{:act :bl, :m :m1, :clk 19996.501}
{:act :ub, :m :m1, :clk 19996.501}

{:act :bl, :m :m1, :clk 19997.501}
{:act :ub, :m :m1, :clk 19997.501}

{:act :bl, :m :m1, :clk 19998.501}
{:act :ub, :m :m1, :clk 19998.501}

which I see A LOT of in the file, is at least a waste of time
How could it be that both are true?


;;;======== "2016-11-12:15-02-57" =====================================

Im implementing :BBS "Block before service" guessing that that is what PSE Toolkit uses. 
BBS interprets the N values differently: Their N = my N-1. With :BBS you count the
machine as a buffer space and you don't start the job until you have a free space
in the buffer.  "Blocked before service implies that the machine itself is a
unit of buffer capacity."

--> It is getting stuck with buffers full and therefore nothing runable.
??? Why doesn't :m5 pull from :b1? ... typo. 


{:TP 0.7736667,
 :observed-cycle-time 11.929943917851551,
 :wip
 {:b1 2.0562942222222076,
  :b2 2.996160722222232,
  :b3 0.18836644444444092,
  :b4 0.08062983333333346},
 :number-of-jobs 13926,
 :computed-cycle-time 10.00987228183126,
 :status :normal-end,
 :runtime 18000,
 :bneck :m2,
 :starved
 {:m1 0.0,
  :m2 0.013425055555555206,
  :m3 0.01869122222222514,
  :m4 0.09859322222222118,
  :m5 0.260458722222219},
 :blocked {:m1 0.0, :m2 0.0, :m3 0.0, :m4 0.0, :m5 0.0}}

So my notion of blocked is all messed up.
I started with the code below. I think new :BBS notion of blocking doesn't
even require that the machine is occupied. 



(defn new-blocked?
  "Return record-actions to list add blocked machines."
  [model]
  (let [clock (:clock model)
        old-blocked (:blocked model)
        new-blocked (as-> (:line model) ?m
                      (vals ?m)
                      (filter machine? ?m)
                      (filter #(occupied? %) ?m)
                      (filter #(finished? model %) ?m)
                      (filter #(not (contains? old-blocked (:name %))) ?m)
                      (filter #(case (:blocking-convention model)
                                 :BAS (buffer-full? model %)
                                 :BBS (not (room-to-start-job? model %))) ?m))]
    (when (not-empty new-blocked)
      (map (fn [mn] `(~clock (new-blocked ~(:name mn)))) new-blocked))))

(defn new-unblocked?
  "Return record-actions to unlist certain machines as blocked."
  [model]
  (let [clock (:clock model)
        old-blocked (:blocked model)
        new-unblocked (as-> (:line model) ?m
                        (vals ?m)
                        (filter machine? ?m)
                        (filter #(contains? old-blocked (:name %)) ?m)
                        (filter #(case (:blocking-convention model)
                                   :BAS (not (buffer-full? model %))
                                   :BBS (room-to-start-job? model %)?m) ?m))]
    (when (not-empty new-unblocked)
      (map (fn [mn] `(~clock (new-unblocked ~(:name mn)))) new-unblocked))))


{:TP 0.77844447,
 :observed-cycle-time 11.690021053382841,
 :wip
 {:b1 2.0142147777778048,
  :b2 2.902455777777759,
  :b3 0.17936905555555666,
  :b4 0.06866477777777884},
 :number-of-jobs 14012,
 :computed-cycle-time 11.156655230062547,
 :status :normal-end,
 :runtime 18000,
 :bneck :m4,
 :starved
 {:m1 0.0,                      0.0
  :m2 0.014215499999999716,     0.0089 ; 1.60
  :m3 0.020909722222222676,     0.0186 ; 1.124
  :m4 0.10207027777778052,      0.0462 ; 2.209
  :m5 0.2689532777777781},      0.1860 ; 1.445
 :blocked
 {:m1 0.26184638888890693,      0.1860 ; 1.408
  :m2 0.11446411111111052,      0.0346 ; 3.308
  :m3 0.1793040000000011,       0.1046 ; 1.714
  :m4 0.06866477777777884,      0.0398 ; 1.725
  :m5 0.0}}


;;; Running :BAS I didn't realize that WIP numbers are pretty good.
;;; Other things did not change (good)

;;; Since WIP and TP are so good, is it safe to say that I'm just
;;; measuring starvation and blockage wrong? 

{:TP 0.8436111,
 :observed-cycle-time 12.807416134343141,
 :wip
 {:b1 2.606784388888886,
  :b2 2.766213888888887,
  :b3 0.6211257222222203,
  :b4 0.16853683333333305},
 :number-of-jobs 15185,
 :computed-cycle-time 11.206624021458383,
 :status :normal-end,
 :runtime 18000,
 :bneck :m2,
 :starved
 {:m1 0.0,
  :m2 0.008565388888888428,
  :m3 0.033533333333339015,
  :m4 0.07087149999999683,
  :m5 0.21102411111111027},
 :blocked
 {:m1 0.10282033333333412,
  :m2 0.019488555555555193,
  :m3 0.052412388888888814,
  :m4 0.018732722222220975,
  :m5 0.0}}

;;; WIP gets WORSE with time!
{:TP 0.8410611,
 :observed-cycle-time 12.86198621450428,
 :wip
 {:b1 2.625023188888899,
  :b2 2.744170527777784,
  :b3 0.6211585611111277,
  :b4 0.17764211666663093},
 :number-of-jobs 151391,
 :computed-cycle-time 11.230465204238815,
 :status :normal-end,
 :runtime 180000,
 :bneck :m2,
 :starved
 {:m1 0.0,
  :m2 0.008187072222222034,
  :m3 0.03422367777777789,
  :m4 0.06945814999998447,
  :m5 0.20843971111112922},
 :blocked
 {:m1 0.10521383333331491,
  :m2 0.021266444444441854,
  :m3 0.055574577777767344,
  :m4 0.020135961111105948,
  :m5 0.0}}

{:blocked
 {:m1 0.1860
  :m2 0.0346
  :m3 0.1046
  :m4 0.0398
  :m5 0.0},
 :starved
 {:m1 0.0
  :m2 0.0089
  :m3 0.0186
  :m4 0.0462
  :m5 0.1860},
 :status :normal-end}



{:TP 0.7786667,
 :observed-cycle-time 11.708897331620987,
 :wip
 {:b1 2.0318187777777674,
  :b2 2.85921555555557,
  :b3 0.17927294444445088,
  :b4 0.06773405555555567},
 :number-of-jobs 14016,
 :computed-cycle-time 11.121383796359165,
 :status :normal-end,
 :runtime 18000,
 :bneck :m4,
 :starved
 {:m1 0.0,
  :m2 0.014888722222221746,
  :m3 0.023485277777768133,
  :m4 0.10141311111111366,
  :m5 0.26658372222222565},
 :blocked
 {:m1 0.2626517222222199,
  :m2 0.10964294444444449,
  :m3 0.17927283333333977,
  :m4 0.06773405555555567,
  :m5 0.0}}

;;; job-moves-to-down-machines=true (BBS)

 :compared-starve
 {:m1 :na,
  :m2 1.4597253433208344,
  :m3 1.22744623655889,
  :m4 2.0823015873016786,
  :m5 1.3887261051373723},
 :compared-block
 {:m1 1.4072383512544915,
  :m2 3.287292870905587,
  :m3 1.7439462502655483,
  :m4 1.8654899497487003,
  :m5 :na},

;;; jobs-move-to-down-machines=false (BBS) worse (as expected; less buffer, more blockage)

 :compared-starve
 {:m1 :na,
  :m2 1.77998127340821,
  :m3 1.1833034647548282,
  :m4 2.1404641654641057,
  :m5 1.4208142174432659},
 :compared-block
 {:m1 1.4416556152926623,
  :m2 3.5633911368014943,
  :m3 1.821074994688694,
  :m4 2.040383863763362,
  :m5 :na},


.... Back to wondering whether it is adding things up correctly

gov.nist.desim> (check-m1)
0.10565194444444811

 :blocked
 {:m1 0.10565194444444811,

... No problem there!

---> Problem??? I advance through future to get the completion time of a job.
Do the down times that I throw away matter? (I think not, everything about
the down time that is needed is expressed in the end time.)

---> Problem??? The record-actions all have :clock as the time of occurrence.
     Shouldn't they be the min-time from runables? A: The query versions of
     these are all based on :clock; no action should be before :clock, so
     this is the min-time. 

I'm thinking that the blocking condition for :BBS is over-stating because
machine may be starved:


... So should I used occupied and finished in all cases?

Before:
 :compared-block
 {:m1 1.4475549581840754,
  :m2 3.3203018625562044,
  :m3 1.7711212024644187,
  :m4 1.8760455053043146,
  :m5 :na},

After:
Oops. I've been here before:
 :compared-block {:m1 0.0, :m2 0.0, :m3 0.0, :m4 0.0, :m5 :na},

:maybe just check for finished? :

 :compared-block
 {:m1 1.4167664277180545,
  :m2 3.5248298008991474,
  :m3 1.7650371786701269,
  :m4 1.8290996649916191,
  :m5 :na},

 :compared-block
 {:m1 1.4063617084826587,
  :m2 3.3206037251124325,
  :m3 1.7572801147227088,
  :m4 1.870880792853136,
  :m5 :na},


Yes, a simplification. But not an improvement.

PROBLEM: I don't see how to calculate blocking with BBS. It seems that the 

I back out of this:


(defn new-blocked?
  "Return record-actions to list add blocked machines."
  [model]
  (let [clock (:clock model)
        old-blocked (:blocked model)
        new-blocked (as-> (:line model) ?m
                      (vals ?m)
                      (filter machine? ?m)
                      (filter #(buffer-full? model %) ?m)
                      (filter #(not (contains? old-blocked (:name %))) ?m)
                      (filter #(finished? model %) ?m))]
    (when (not-empty new-blocked)
      (map (fn [mn] `(~clock (new-blocked ~(:name mn)))) new-blocked))))


TYPO!!! 

                        (filter #(case (:blocking-convention model)
                                   :BAS (not (buffer-full? model %))
                                   :BBS (room-to-start-job? model %)?m) ?m))]

The ?m will make this return true. It is in unblock, so correcting this will only
make things worse!

 :compared-block
 {:m1 1.4236786140979707,
  :m2 3.4187716763005405,
  :m3 1.8039685574676154,
  :m4 1.9124427694025519,
  :m5 :na},

Did not change!

:BAS is still more accurate, at least so for measurement of starvation. 

 :compared-starve
 {:m1 :na,
  :m2 0.9870724094881392,
  :m3 1.7150567502987588,
  :m4 1.4145851370851459,
  :m5 1.1235863201911371},
 :compared-block
 {:m1 0.5662813620072075,
  :m2 0.5896082209377337,
  :m3 0.5319773741236548,
  :m4 0.5149874371859415,
  :m5 :na},


;;; And then I learn (9PM) that I shouldn't be bothering with :BBS on a continuous analysis.
;;; (pg 85) Do what makes sense.


;;;============= "2016-11-13 09:05:17" =====================

--> I ran the PSE simulator

- It runs about 100 times faster than my program.
- WIP and TP confidence interval looks to be 3 digits.
- Blocking and starvation good to 2 or 3 digits (similar to mine at 200,000)
- The results don't match theoretical either: 

Theoretical is 3rd column

Starvation 2runs  Theoretical
0        0          0             ERROR                  MY ERROR   Diff (minus good)
0.0093   0.0092     0.0089    1.0337078651685394          0.99       -4%
0.0299   0.0295     0.0186    1.5967741935483872          1.71       +11%
0.0689   0.0683     0.0462    1.4826839826839828          1.41       -7%
0.2089   0.2079     0.1860    1.1209677419354838          1.12        0

Blocking 2runs
0.2088 0.2082      0.1860     1.1209677419354838          0.566      213%
0.0615 0.0609      0.0346     1.76878612716763            0.590      299%
0.1160 0.1160      0.1046     1.1089866156787764          0.532      208%
0.0412 0.0414      0.0398     1.0376884422110553          0.515      201%
0      0           0.0

TP                                                       MY VALUE
0.8275  0.8284     0.8569     0.9667405764966741         0.8401222,


---> Conclusions:

- I'll need to switch to mutables to increase speed.
- I'll need to remove eliminate (before written) crap in log.
- I'll need to fix the error in blocking numbers (starvation is fine)
- My throughput is closer to theoretical, but it probably won't be after fixing blocking. 


          "Elapsed time: 52363.534219 msecs" -- Baseline
          "Elapsed time: 49860.95785  msecs" -- memoized 3 functions.
          "Elapsed time: 50110.317524 msecs" -- transient jcycles (but not the contained map)
	  "Elapsed time: 34917.137122 msecs" -- switched to in-memory log
 	                349228.707387 msecs" -- 10 times larger problem. scales nice Still 5.8 minutes
          "Elapsed time: 36830.55599  msecs" -- little bit of variation
	  "Elapsed time: 29007.639572 msecs" -- WOW replace (-> (:line model) (vals) (filter ?machines)
	  "Elapsed time: 28807.931985 msecs" -- removed job?
          "Elapsed time: 28293.980291 msecs" -- consolidated filters (pointless
	  "Elapsed time: 28470.465113 msecs" -- inline predicates (pointless)
	  "Elapsed time: 28427.512472 msecs" -- transient result / no conj log (pointless, but less memory)
	  "Elapsed time: 30042.970962 msecs" -- using transient data types for results map.
          "Elapsed time: 26829.292236 msecs" -- Still using transients (new start)
	  "Elapsed time: 27325.827721 msecs" -- Pulled out the transients

Processing results is only 4 seconds "Elapsed time: 46274.242745 msecs" (was 50).
Writing to log is 10 seconds         "Elapsed time: 36408.674899 msecs" (Total 14 sec on post-processing)
... which means that most of the time is spent manipulating the model.

So far only saved 17 seconds out of 52

Things that might help
 1) The logging can do the basics results work. (Will save memory, maybe not save time.)
 2) Transient results. DONE pointless
 3) More work to reduce use of many filters. - DONE pointless.
 4) In-line tests  - DONE pointless
 5) Transient model


Results form used to look like this:
{:m5 {:blocked 0.0, :starved 0.0, :bs nil, :ss nil},
 :b2 {0 0.0, 1 0.0, 2 0.0, 3 0.0, 4 0.0, 5 0.0, :lastclk 2000},
 :m3 {:blocked 0.0, :starved 0.0, :bs nil, :ss nil},
 :b1 {0 0.0, 1 0.0, 2 0.0, 3 0.0, :lastclk 2000},
 :m4 {:blocked 0.0, :starved 0.0, :bs nil, :ss nil},
 :b4 {0 0.0, 1 0.0, :lastclk 2000},
 :m2 {:blocked 0.0, :starved 0.0, :bs nil, :ss nil},
 :b3 {0 0.0, 1 0.0, :lastclk 2000},
 :jcycles
 #object[clojure.lang.PersistentVector$TransientVector 0x3067e854 "clojure.lang.PersistentVector$TransientVector@3067e854"],
 :m1 {:blocked 0.0, :starved 0.0, :bs nil, :ss nil}}

Came from here.
#_(defn results-form [model]
  (as-> {:jcycles (transient [])} ?r
      (into ?r (map (fn [m] [m {:blocked 0.0 :starved 0.0 :bs nil :ss nil}])
                         (:machines model)))
      (into ?r (map (fn [b] [(:name b) (assoc (zipmap (range (inc (:N b))) (repeat (+ 2 (:N b)) 0.0))
                                              :lastclk (:warm-up-time (:params model)))])
                    (map #(lookup model %) (:buffers model))))))


{:TP 0.84066665,
 :observed-cycle-time 12.878425570058035,
 :compared-starve
 {:m1 :na,
  :m2 0.9889110959499797,
  :m3 1.7866981185635784,
  :m4 1.481936310003061,
  :m5 1.121313910900014},
 :compared-block
 {:m1 0.5555655710460904,
  :m2 0.627585073747892,
  :m3 0.5365683886639725,
  :m4 0.5200317672610617,
  :m5 :na},
 :wip
 {:b1 2.6167471739220556,
  :b2 2.75246542938637,
  :b3 0.6282422611624172,
  :b4 0.17736768849359807},
 :number-of-jobs 151320,
 :computed-cycle-time 11.237464444493437,
 :status nil,
 :runtime 180000,
 :bneck :m2,
 :starved
 {:m1 0.0,
  :m2 0.00880130875395482,
  :m3 0.033232585005282554,
  :m4 0.0684654575221414,
  :m5 0.2085643874274026},
 :blocked
 {:m1 0.10333519621457282,
  :m2 0.02171444355167706,
  :m3 0.056125053454251526,
  :m4 0.02069726433699026,
  :m5 0.0}}
"Elapsed time: 284089.170582 msecs"

2016-12-15: Continuing with optimization

            "Elapsed time: 52363.534219 msecs" -- Baseline
            "Elapsed time: 49860.95785  msecs" -- memoized 3 functions.
            "Elapsed time: 50110.317524 msecs" -- transient jcycles (but not the contained map)
	    "Elapsed time: 34917.137122 msecs" -- switched to in-memory log
 	                  349228.707387 msecs" -- 10 times larger problem. scales nice Still 5.8 minutes
            "Elapsed time: 36830.55599  msecs" -- little bit of variation
	    "Elapsed time: 29007.639572 msecs" -- WOW replace (-> (:line model) (vals) (filter ?machines)
	    "Elapsed time: 28807.931985 msecs" -- removed job?
            "Elapsed time: 28293.980291 msecs" -- consolidated filters (pointless
	    "Elapsed time: 28470.465113 msecs" -- inline predicates (pointless)
	    "Elapsed time: 28427.512472 msecs" -- transient result / no conj log (pointless, but less memory)
	    "Elapsed time: 30042.970962 msecs" -- using transient data types for results map.
            "Elapsed time: 26829.292236 msecs" -- Still using transients (new start)
	    "Elapsed time: 27325.827721 msecs" -- Pulled out the transients
2016-12-15: "Elapsed time: 24784.483535 msecs" -- Switched away from resolve symbol for function name.
            "Elapsed time: 23095.651639 msecs" -- Before 4 calls that used reflection.
            "Elapsed time:  9086.706559 msecs" -- WOW WOW WOW 4 calls that used reflection (really, I put it back to be sure.)
2016-12-16: "Elapsed time: 13606.390432 msecs" -- working again. OUCH!
            "Elapsed time: 13483.304806 msecs" -- restart emacs.
	    "Elapsed time: 13803.465356 msecs" -- reboot!
2016-12-17: "Elapsed time: 13968.056614 msecs" -- Accepting the memoization things from slow.clj
            "Elapsed time:  9838.200520 msecs" -- Accepting the map/reduce changes (still a step backwards)
            "Elapsed time:  8826.595281 msecs" -- Pre-macro code after a new jack-in.
            "Elapsed time:  9307.708943 msecs" -- Removed macros. Still a step backwards
            "Elapsed time:  9198.021882 msecs" -- Original fast code ==> NOTHING I did yeterday improved matters.
	    "Elapsed time:  9173.616706 msecs" -- new jack-in.
	    "Elapsed time:  9888.031048 msecs" -- NEW BASELINE (one jobtype)
            "Elapsed time: 10814.131758 msecs" -- Removed macros (not a step backwards, or forwards). 

OK, I've figured it out! The problem is that I *did* have reflection in the main loop: My memoization is
not going to work because I am passing in the model. In fact, memoizing those functions will only make it worse!

;;; 2016-12-16 =============================================

This looks wrong! Of course the nil as a key (of what?) is wrong, but also why is the
buffer occupancy for :b2 0.0 for everything except 5. Isn't that backwards?

{nil {:blocked 0.0, :starved 0.0, :bs nil, :ss nil},
 :m5 {:ss 2002.2282261532864},
 :b2 {0 0.0, 1 0.0, 2 0.0, 3 0.0, 4 0.0, 5 2.2670902213321824, :lastclk 2002.2670902213322},
 :b1 {0 0.0, 1 0.0, 2 0.0, 3 0.0, :lastclk 2000},
 :njobs 3,
 :m4 {:ss 2000.918702343763},
 :residence-sum 61.115749023345415,
 :b4  {0 0.357142857143117,   1 1.0377499628100395, :lastclk 2001.3948928199532},
 :m2 {:bs 2000.56155948662},
 :b3 {0 2.2670902213321824, 1 0.0, :lastclk 2002.2670902213322},
 :m1 {:bs 2001.3948928199532}}

;;; 2016-12-16 =============================================

I learn that *nothing* I did yesterday improved performance. I removed it all. 

The two-jobtype f1 runs 10% faster than the one-jobtype f1!
YES, that make sense. If a job takes a long time on the machine, it advances time faster. 

---------------------------------------------------------------------------------

I think they (paper and Semyon's book) are going about it wrong in identifying the bottleneck machine.

1) Here I have work on :m3 taking 10 times longer than :m4, but m4 is identified by their algorithm
  as being the bottleneck machine. 

Candidates = (:m3 :m4)
severity =  {:m1 0.8015309176123412, :m2 1.5451461383501668, :m3 1.6270555803135731, :m4 1.7795514868027529, :m5 0.8961111272270053}
{:TP 0.09910555,
 :computed-residence-time 66.43362645014875,
 :number-of-jobs 17839,
 :avg-buffer-occupancy
 {:b1 2.9999337065725595,
  :b2 4.999908022848531,
  :b3 0.011662631515891654,
  :b4 0.011785256557027059},
 :status nil,
 :runtime 13.998,
 :starved
 {:m1 0.0,
  :m2 0.0,
  :m3 0.0,
  :m4 0.8834403595757475,
  :m5 0.8961111272270053},
 :observed-residence-time 113.11440752738957,
 :blocked
 {:m1 0.8015309176123412,
  :m2 0.7436152207378257,
  :m3 0.0,
  :m4 0.0,
  :m5 0.0},
 :bottleneck-machine :m4}

2) If I double the capacity of :m3 I double the throughput.
  :TP 0.19825555 versus :TP 0.09910555,
  severity =  {:m1 0.6955007377283172, :m2 1.2663746298643215, :m3 1.3394801706743182, :m4 1.5634577009685098, :m5 0.7948514224301957}
  
  If I instead double the capacity of :m4, of course, not much will happen. :TP 0.09899444,
  severity =  {:m1 0.7401401011929946, :m2 1.4898454308192328, :m3 1.6864115246260458, :m4 1.8347113566189455, :m5 0.8980051616191379}

Clearly the bottleneck identified by the algorthm doesn't match the one identified by
the the definition (change in TP wrt change in W). 

My edits for calc-residence-time (rename it!) are not working out.
BTW Little formula says TP = WIP / RT  which is about 10% off using the observed residence.

ToDo:
(1) Make output cleaner:
  :thoughput {:obseved xx :calculated yy}
  :residence {:observed zz :calculated ww}
(2) Make the example runtime 100000
(3) Fix problem with warn-on-reflection in build.
(4) Update README with example.
(5) Rename :runtime --> :program-execution-time 

---> Semyon's bottleneck identification algorithm is not so good!

;;; 2017-01-12 =============================================

Hi John,

As I mentioned, I think genetic programming (GP) has a role in what we are doing. In fact, I'm going to try using it on the MJPDES problem MJPdes problem.
If you recall, what I consider "the MJPdes problem" is that I use one set of definitions for blocking and starving and U. Mich uses another.
What I'd like to be able to do is discover what definition is being used. I should be able to run a training set of simulations with MJPdes and
then use that with GP to find the set of condition that correspond to my definitions:

(filter #(and 
	   (buffer-full? model %)
           (not (contains? old-block (:name %)))
           (occupied? %) 
           (finished? model %)) 
           (machines model))

(Note: The (not (contains? ...)) wouldn't be part of the code that the GP algorithm designs. I can finesse it out, I think.) The fitness of a gene will be assessed by dropping the created blocking function into the program and comparing results against the training data. I am currently trying to get the MJPdes code to run concurrently, and with a spread of models e.g.

 {...model definition
    :number-of-simulations 1000
    :jobmix {:jobType1 (map->JobType {:portion 1.0
                                      :w {:m1 {:dist :uniform :bounds [0.8,1.2]},
                                          :m2 {:dist :uniform :bounds [0.8,1.2]},
                                          :m3 {:dist :uniform :bounds [0.8,1.2]},
                                          :m4 {:dist :uniform :bounds [0.8,1.2]},
                                          :m5 {:dist :uniform :bounds [0.8,1.2]}}})}}))

Another task towards making this work is running it on a compute server. I have been screwing around with EC2 and docker, https://hub.docker.com/r/podenno/mjpdes-docker/~/dockerfile/ I barely know what I'm doing with this technology. I see that you have used some AWS stuff; when we meet Wednesday maybe you can help me figure out how to run simulations. I'm not clear, for example, how I get results back.

Backing away from all this detail, learning the blocking definition used (the purpose of the exercise) demonstrates a more generally useful capability, I think. I would argue (I'm thinking about what I'd publish now) that making discrete event simulation a composable service is hampered by not knowing exactly what modeling decisions (like blocking definition) are being used. A colleague at NIST who has been looking to define a "canonical" DES language has been bumping up against this very problem -- every DES software provider does something different. I ran across this in Pearl's Causality:

"An autonomous intelligent system attempting to buid a workable model of its environment cannot rely exclusively on preprogrammed causal knowledge; rather, it must be able to translate direct observations to cause-and-effect relationships."

I think I'll be using one causal model (and ologs) to decide what the operators are for the GP problem. The result will be a more detailed causal model (or possibly a FSM).

If this works at all, I'll try something similar with the Orthogonal cutting problem, developing the finite element analysis Johnson-Cook damage model with GP using experimental data. This is more clearly a symbolic regression problem (Probably use GPTIPS2). The goal in this exercise would be to 
make the FEA more widely applicable (capable of good prediction over a range of material properties. How I actually make this work needs a lot more study. Among the problems is whether it will be feasible to run the FEA many times.

Best regards,
  Peter

;;;=========================
;;; 2017-01-15
;;;=========================

Mostly today I will be working on slides, but I note also that though
(-main "-i" "resources/example.clj" "-o" "resources/new-out.clj") works,
something similar using the command line doesn't -- it results in a file
new-out.clj of size 0.

Also docker run has an exec format error.

;;;=========================
;;; 2017-01-21
;;;=========================

The error noted above is probably just due to not doing lein bin.

I also got past the docker error. 








